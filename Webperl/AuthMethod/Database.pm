## @file
# This file contains the implementation of the Database authentication class.
#
# @author  Chris Page &lt;chris@starforge.co.uk&gt;
#
# This program is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program.  If not, see http://www.gnu.org/licenses/.

## @class
# Implementation of a basic database authentication class. This will
# compare a user's credentials to those stored in a database table.
# The users' passwords are never stored as plain text - this uses a
# salted, hashed storage mechanism for passwords.
#
# This module will expect at least the following configuration values
# to be passed to the constructor.
#
# * table     - The name of the database table to authenticate against.
#               This must be accessible to the system-wide dbh object.
# * userfield - The name of the column in the table that stores usernames.
# * passfield - The password column in the table. The field in the table
#               must be able to store a 59 character hashed password.
#
# The following arguments may also be provided to the module constructor:
#
# * bcrypt_cost - the number of iterations of hashing to perform. This
#                 defaults to COST_DEFAULT if not specified.
package Webperl::AuthMethod::Database;

use strict;
use base qw(Webperl::AuthMethod); # This class extends AuthMethod
use Crypt::Eksblowfish::Bcrypt qw(bcrypt en_base64);

use constant COST_DEFAULT => 14; # The default cost to use if bcrypt_cost is not set.


# ============================================================================
#  Constructor

## @cmethod $ new(%args)
# Construct a new AuthMethod object. This will create a new AuthMethod object
# initialised with the provided arguments. All the arguments are copied into
# the new object 'as is', with no processing - the caller must make sure they
# are sane before calling this.
#
# @param args A hash of arguments to initialise the AuthMethod object with.
# @return A new AuthMethod object on success, an error message otherwise.
sub new {
    my $invocant = shift;
    my $class    = ref($invocant) || $invocant;
    my $self     = $class -> SUPER::new(@_);

    # bomb if the parent constructor failed.
    return $class -> SUPER::get_error() if(!$self);

    # Set default values as needed
    $self -> {"bcrypt_cost"} = COST_DEFAULT;

    # check that required settings are set...
    return "Webperl::AuthMethod::Database missing 'table' argument in new()" if(!$self -> {"table"});
    return "Webperl::AuthMethod::Database missing 'userfield' argument in new()" if(!$self -> {"userfield"});
    return "Webperl::AuthMethod::Database missing 'passfield' argument in new()" if(!$self -> {"passfield"});

    return $self;
}


# ============================================================================
#  Interface code

## @method $ hash_password($password, $settings)
# Generate a salted hash of the supplied password. This will create a 59 character
# long string containing the hashed password and its salt suitable for storing in
# the database. If the $settings string is not provided, one will be generated.
# When creating accounts, $settings will be omitted unless the caller wants to
# provide its own salting system. When checking passwords, password should be the
# password being checked, and settings should be a hash string previously
# generated by this function. The result of this function can then be compared to
# the stored hash to determine whether the password is correct.
#
# @param password The plain-text password to check.
# @param settings An optional settings string, leave undefined for new accounts,
#                 set to a previously generated hash string when doing password
#                 validity checking.
# @return A bcrypt() generated, 59 character hash containing the settings string
#         and the hashed, salted password.
sub hash_password {
    my $self     = shift;
    my $password = shift;
    my $settings = shift || generate_settings($self -> {"bcrypt_cost"});

    return bcrypt($password, $settings);
}


## @method @ create_user($username, $authmethod, $email)
# Create a new user, with a randomly generated password and activation code.
# This will set the user's name, email, password, activation code, and creation
# date, all other fields will be defaults.
#
# @param username   The username of the user to create a record for.
# @param authmethod The ID of the authmethod to set as the user's default authmethod.
# @param email      The email address of the new user.
# @return An array of two values: the first is either a reference to the user's
#         new record data on success, or undef on failure; the second is the
#         10 character alphanumeric unencrypted password to send to the user.
sub create_user {
    my $self       = shift;
    my $username   = shift;
    my $authmethod = shift;
    my $email      = shift;

    # Generate some randomness for the authcode and password. These don't need
    # to be Insanely Secure, so this should be sufficient...
    my $actcode  = join("", map { ("a".."z", "A".."Z", 0..9)[rand 62] } 1..64);
    my $password = join("", map { ("a".."z", "A".."Z", 0..9)[rand 62] } 1..10);

    # Hash the password using the method AuthMethod::Database uses internally
    my $cryptpass = $self -> hash_password($password);

    # Do the insert
    my $userh = $self -> {"dbh"} -> prepare("INSERT INTO ".$self -> {"settings"} -> {"database"} -> {"users"}."
                                             (user_auth, username, password, email, created, act_code)
                                             VALUES(?, ?, ?, ?, UNIX_TIMESTAMP(), ?)");
    my $rows = $userh -> execute($authmethod, $username, $cryptpass, $email, $actcode);
    return $self -> self_error("Unable to perform user insert: ". $self -> {"dbh"} -> errstr) if(!$rows);
    return $self -> self_error("User insert failed, no rows added.") if($rows eq "0E0");

    # FIXME: This ties to MySQL, but is more reliable that last_insert_id in general.
    #        Try to find a decent solution for this mess...
    my $userid = $self -> {"dbh"} -> {"mysql_insertid"};
    return $self -> self_error("Unable to obtain id for user '$username'") if(!$userid);

    $userh = $self -> {"dbh"} -> prepare("SELECT * FROM  ".$self -> {"settings"} -> {"database"} -> {"users"}."
                                          WHERE user_id = ?");
    $userh -> execute($userid)
        or return $self -> self_error("Unable to fetch user record: ".$self -> {"dbh"} -> errstr);

    return ($userh -> fetchrow_hashref(), $password);
}


## @method $ authenticate($username, $password, $auth)
# Attempt to authenticate the user against the database. This will check the user's
# login against the configured database tabke, and return true if the login is valid.
#
# @param username The username to check against the database.
# @param password The password to check against the database.
# @param auth     A reference to the Auth object calling this function,
#                 if any errors are encountered while performing the
#                 authentication, they will be set in $auth -> {"errstr"}.
# @return true if the user's credentials are valid, false otherwise.
sub authenticate {
    my $self     = shift;
    my $username = shift;
    my $password = shift;
    my $auth     = shift;

    my $userh = $self -> {"dbh"} -> prepare("SELECT ".$self -> {"passfield"}." FROM ".$self -> {"table"}."
                                             WHERE ".$self -> {"userfield"}." LIKE ?");
    $userh -> execute($username)
        or $self -> {"logger"} -> die_log($self -> {"cgi"} -> remote_host(), "Unable to execute user lookup query: ".$self -> {"dbh"} -> errstr);

    # If a user has been found with the specified username, check the password...
    my $user = $userh -> fetchrow_arrayref();
    if($user && $user -> [0]) {
        my $hash = $self -> hash_password($password, $user -> [0]);

        # If the new hash matches the stored hash, the password is valid.
        return ($hash eq $user -> [0]);
    }

    return 0;
}


## @method $ require_activate()
# Determine whether the AuthMethod module requires that user accounts
# be activated before they can be used.
#
# @return true if the AuthMethod requires activation, false if it does not.
sub require_activate {
    my $self = shift;

    return 1;
}


## @method $ activated($userid)
# Determine whether the user account specified has been activated.
#
# @param userid The ID of the user account to check the activation status of.
# @return true if the user has been activated (actually, the unix timestamp of
#         their activation), 0 if the user has not been activated/does not exist,
#         or undef on error.
sub activated {
    my $self = shift;
    my $userid  = shift;

    $self -> clear_error();

    my $acth = $self -> {"dbh"} -> prepare("SELECT activated FROM ".$self -> {"settings"} -> {"database"} -> {"users"}."
                                            WHERE user_id = ?");
    $acth -> execute($userid)
        or return $self -> self_error("Unable to perform user activation check: ". $self -> {"dbh"} -> errstr);

    my $act = $acth -> fetchrow_arrayref();
    return $act ? $act -> [0] : 0;
}


## @method $ activate_user($userid)
# Activate the user account with the specified id. This clears the user's
# activation code, and sets the activation timestamp.
#
# @param userid The ID of the user account to activate.
# @return true on success, undef on error.
sub activate_user {
    my $self   = shift;
    my $userid = shift;

    $self -> clear_error();

    my $activate = $self -> {"dbh"} -> prepare("UPDATE ".$self -> {"settings"} -> {"database"} -> {"users"}."
                                                SET activated = UNIX_TIMESTAMP(), act_code = NULL
                                                WHERE user_id = ?");
    my $rows = $activate -> execute($userid);
    return $self -> self_error("Unable to perform user update: ". $self -> {"dbh"} -> errstr) if(!$rows);
    return $self -> self_error("User update failed, no rows modified - bad userid?") if($rows eq "0E0");

    return 1;
}


## @method $ supports_recovery()
# Determine whether the AuthMethod allows users to recover their account details
# within the system.
#
# @return True if the AuthMethod supports in-system account recovery, false if it does not.
sub supports_recovery {
    my $self = shift;

    return 1;
}


## @method @ reset_password_actcode($userid)
# Forcibly reset the user's password and activation code to new random values.
#
# @param userid The ID of the user to reset the password and act code for
# @return The new password and activation code set for the user
sub reset_password_actcode {
    my $self   = shift;
    my $userid = shift;

    my $actcode  = join("", map { ("a".."z", "A".."Z", 0..9)[rand 62] } 1..64);
    my $password = join("", map { ("a".."z", "A".."Z", 0..9)[rand 62] } 1..10);

    # Hash the password using the method AuthMethod::Database uses internally
    my $cryptpass = $self -> hash_password($password);

    my $reseth = $self -> {"dbh"} -> prepare("UPDATE ".$self -> {"settings"} -> {"database"} -> {"users"}."
                                              SET password = ?, act_code = ?
                                              WHERE user_id = ?");
    my $rows = $reseth -> execute($cryptpass, $actcode, $userid);
    return $self -> self_error("Unable to perform user update: ". $self -> {"dbh"} -> errstr) if(!$rows);
    return $self -> self_error("User update failed, no rows changed.") if($rows eq "0E0");

    return ($password, $actcode);
}


## @method $ reset_password($userid)
# Forcibly reset the user's password to a new random value.
#
# @param userid The ID of the user to reset the password for
# @return The (unencrypted) new password set for the user
sub reset_password {
    my $self   = shift;
    my $userid = shift;

    my $password = join("", map { ("a".."z", "A".."Z", 0..9)[rand 62] } 1..10);

    # Hash the password using the method AuthMethod::Database uses internally
    my $cryptpass = $self -> hash_password($password);

    my $reseth = $self -> {"dbh"} -> prepare("UPDATE ".$self -> {"settings"} -> {"database"} -> {"users"}."
                                              SET password = ?
                                              WHERE user_id = ?");
    my $rows = $reseth -> execute($cryptpass, $userid);
    return $self -> self_error("Unable to perform user update: ". $self -> {"dbh"} -> errstr) if(!$rows);
    return $self -> self_error("User update failed, no rows changed.") if($rows eq "0E0");

    return $password;
}


## @method $ set_password($userid, $password)
# Set the user's password to the specified value.
#
# @param userid   The ID of the user to set the password for
# @param password The password to set for the user.
# @return True on success, undef on error.
sub set_password {
    my $self     = shift;
    my $userid   = shift;
    my $password = shift;

    # Hash the password using the method AuthMethod::Database uses internally
    my $cryptpass = $self -> hash_password($password);

    my $reseth = $self -> {"dbh"} -> prepare("UPDATE ".$self -> {"settings"} -> {"database"} -> {"users"}."
                                              SET password = ?
                                              WHERE user_id = ?");
    my $rows = $reseth -> execute($cryptpass, $userid);
    return $self -> self_error("Unable to perform user update: ". $self -> {"dbh"} -> errstr) if(!$rows);
    return $self -> self_error("User update failed, no rows changed.") if($rows eq "0E0");

    return 1;
}


## @method $ generate_actcode($userid)
# Generate a new activation code for the specified user.
#
# @param userid The ID of the user to reset the act code for
# @return The new activation code for the user
sub generate_actcode {
    my $self   = shift;
    my $userid = shift;

    my $actcode  = join("", map { ("a".."z", "A".."Z", 0..9)[rand 62] } 1..64);

    my $reseth = $self -> {"dbh"} -> prepare("UPDATE ".$self -> {"settings"} -> {"database"} -> {"users"}."
                                              SET act_code = ?
                                              WHERE user_id = ?");
    my $rows = $reseth -> execute($actcode, $userid);
    return $self -> self_error("Unable to perform user update: ". $self -> {"dbh"} -> errstr) if(!$rows);
    return $self -> self_error("User update failed, no rows changed.") if($rows eq "0E0");

    return $actcode;
}


# ============================================================================
#  Ghastly internals

## @fn private $ generate_settings($cost)
# Generate a settings string to provide to bcrypt(). This will generate a
# string in the form '$2$', followed by the cost - which will be padded with a
# leading zero for you if it is less than 10, and does not have one already -
# followed by '$' and then a 22 character Base64 encoded string containing the
# password salt.
#
# @todo This uses /dev/urandom directly, which is not only unportable, it
#       is cryptographically weak. /dev/random fixes the latter - at the cost
#       of potentially blocking the user, and has therefore been avoided.
#       Possibly switching to Crypt::Random, and doing account creation
#       asynchronously (ie: users do not get immediately created accounts)
#       would allow proper strength salting in a potentially platform-neutral
#       fashion here.
#
# @param cost The cost of the hash. The number of hash iterations is 2^cost.
#             This should be as high as possible (at least 14, preferably over 16)
#             while not drastically slowing user login.
# @return A settings string suitable for use with bcrypt().
sub generate_settings {
    my $cost = shift;

    # Make sure the cost has a leading zero if needed.
    $cost = "0$cost"
        unless($cost > 9 || $cost =~ /^0\d$/);

    # Bytes, bytes, we need random(ish) byes!
    open(RND, "/dev/urandom")
        or die "Unable to open random source: $!\n";
    binmode(RND);

    my $buffer;
    my $read = read(RND, $buffer, 16);
    die "Unable to read 16 bytes from random source: $!\n" if($read != 16);
    close(RND);

    # Can't use MIME::Base64 directly here as bcrypt() expects a somewhat...
    # idiosycratic variation of base64 encoding. Use its own encoder instead.
    return '$2$'.$cost.'$'.en_base64($buffer);
}

1;
