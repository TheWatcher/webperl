## @file
# This file contains the implementation of the Database authentication class.
#
# @author  Chris Page &lt;chris@starforge.co.uk&gt;
#
# This program is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program.  If not, see http://www.gnu.org/licenses/.

## @class
# Implementation of a basic database authentication class. This will
# compare a user's credentials to those stored in a database table.
# The users' passwords are never stored as plain text - this uses a
# salted, hashed storage mechanism for passwords.
#
# This module supports the following comfiguration variables:
#
# - table       (required) The name of the database table to authenticate against.
#                This table must be accessible to the system-wide dbh object.
# - bcrypt_cost (optional) the number of iterations of hashing to perform. This
#                defaults to Webperl::AuthMethod::Database::COST_DEFAULT if not
#                specified.
#
# These will generally be provided by supplying the configuration variables
# in the auth_methods_params table and using Webperl::AuthMethods to load
# the AuthMethod at runtime.
package Webperl::AuthMethod::Database;

use strict;
use base qw(Webperl::AuthMethod); # This class extends AuthMethod
use Crypt::Eksblowfish::Bcrypt qw(bcrypt en_base64);

## The default cost to use if bcrypt_cost is not passed to the constructor.
use constant COST_DEFAULT => 14;


# ============================================================================
#  Constructor

## @cmethod $ new(%args)
# Construct a new AuthMethod object. This will create a new AuthMethod object
# initialised with the provided arguments. All the arguments are copied into
# the new object 'as is', with no processing - the caller must make sure they
# are sane before calling this.
#
# @param args A hash of arguments to initialise the AuthMethod object with.
# @return A new AuthMethod object on success, an error message otherwise.
sub new {
    my $invocant = shift;
    my $class    = ref($invocant) || $invocant;
    my $self     = $class -> SUPER::new(@_)
        or return undef;

    # check that required settings are set...
    return set_error("Webperl::AuthMethod::Database missing 'table' argument in new()")
        if(!$self -> {"table"});

    # Set default values as needed
    $self -> {"bcrypt_cost"} = COST_DEFAULT
        unless($self -> {"bcrypt_cost"});

    # replace the stock capabilities
    $self -> {"capabilities"} = {"activate"           => 1,
                                 "activate_message"   => '',
                                 "recover"            => 1,
                                 "recover_message"    => '',
                                 "passchange"         => 1,
                                 "passchange_message" => '',
                                 "failcount"          => 1,
                                 "failcount_message"  => '',
                                };
    return $self;
}


# ============================================================================
#  Interface code

## @method $ hash_password($password, $settings)
# Generate a salted hash of the supplied password. This will create a 59 character
# long string containing the hashed password and its salt suitable for storing in
# the database. If the $settings string is not provided, one will be generated.
# When creating accounts, $settings will be omitted unless the caller wants to
# provide its own salting system. When checking passwords, password should be the
# password being checked, and settings should be a hash string previously
# generated by this function. The result of this function can then be compared to
# the stored hash to determine whether the password is correct.
#
# @param password The plain-text password to check.
# @param settings An optional settings string, leave undefined for new accounts,
#                 set to a previously generated hash string when doing password
#                 validity checking.
# @return A bcrypt() generated, 59 character hash containing the settings string
#         and the hashed, salted password.
sub hash_password {
    my $self     = shift;
    my $password = shift;
    my $settings = shift || generate_settings($self -> {"bcrypt_cost"});

    return bcrypt($password, $settings);
}


## @method @ create_user($username, $authmethod, $email)
# Create a new user, with a randomly generated password and activation code.
# This will set the user's name, email, password, activation code, and creation
# date, all other fields will be defaults.
#
# @param username   The username of the user to create a record for.
# @param authmethod The ID of the authmethod to set as the user's default authmethod.
# @param email      The email address of the new user.
# @return An array of two values: the first is either a reference to the user's
#         new record data on success, or undef on failure; the second is the
#         10 character alphanumeric unencrypted password to send to the user.
sub create_user {
    my $self       = shift;
    my $username   = shift;
    my $authmethod = shift;
    my $email      = shift;

    # Generate some randomness for the authcode and password. These don't need
    # to be Insanely Secure, so this should be sufficient...
    my $actcode  = join("", map { ("a".."z", "A".."Z", 0..9)[rand 62] } 1..64);
    my $password = join("", map { ("a".."z", "A".."Z", 0..9)[rand 62] } 1..10);

    # Hash the password using the method AuthMethod::Database uses internally
    my $cryptpass = $self -> hash_password($password);

    # Do the insert
    my $userh = $self -> {"dbh"} -> prepare("INSERT INTO ".$self -> {"settings"} -> {"database"} -> {"users"}."
                                             (user_auth, username, password, password_set, force_change, email, created, act_code)
                                             VALUES(?, ?, ?, UNIX_TIMESTAMP(), 1, ?, UNIX_TIMESTAMP(), ?)");
    my $rows = $userh -> execute($authmethod, $username, $cryptpass, $email, $actcode);
    return $self -> self_error("Unable to perform user insert: ". $self -> {"dbh"} -> errstr) if(!$rows);
    return $self -> self_error("User insert failed, no rows added.") if($rows eq "0E0");

    # FIXME: This ties to MySQL, but is more reliable that last_insert_id in general.
    #        Try to find a decent solution for this mess...
    my $userid = $self -> {"dbh"} -> {"mysql_insertid"};
    return $self -> self_error("Unable to obtain id for user '$username'") if(!$userid);

    $userh = $self -> {"dbh"} -> prepare("SELECT * FROM  ".$self -> {"settings"} -> {"database"} -> {"users"}."
                                          WHERE user_id = ?");
    $userh -> execute($userid)
        or return $self -> self_error("Unable to fetch user record: ".$self -> {"dbh"} -> errstr);

    return ($userh -> fetchrow_hashref(), $password);
}


## @method $ authenticate($username, $password, $auth)
# Attempt to authenticate the user against the database. This will check the user's
# login against the configured database tabke, and return true if the login is valid.
#
# @param username The username to check against the database.
# @param password The password to check against the database.
# @param auth     A reference to the Auth object calling this function,
#                 if any errors are encountered while performing the
#                 authentication, they will be set in $auth -> {"errstr"}.
# @return true if the user's credentials are valid, false otherwise.
sub authenticate {
    my $self     = shift;
    my $username = shift;
    my $password = shift;
    my $auth     = shift;

    return $auth -> self_error("Database login failed: Username and password are required.")
        if(!$username || !$password);

    my $userh = $self -> {"dbh"} -> prepare("SELECT password FROM ".$self -> {"table"}."
                                             WHERE username LIKE ?");
    $userh -> execute($username)
        or return $auth -> self_error("Database login failed: Unable to execute user lookup query: ".$self -> {"dbh"} -> errstr);

    # If a user has been found with the specified username, check the password...
    my $user = $userh -> fetchrow_arrayref();
    if($user && $user -> [0]) {
        my $hash = $self -> hash_password($password, $user -> [0]);

        # If the new hash matches the stored hash, the password is valid.
        return ($hash eq $user -> [0]);
    }

    return 0;
}


## @method $ activated($userid)
# Determine whether the user account specified has been activated.
#
# @param userid The ID of the user account to check the activation status of.
# @return true if the user has been activated (actually, the unix timestamp of
#         their activation), 0 if the user has not been activated/does not exist,
#         or undef on error.
sub activated {
    my $self = shift;
    my $userid  = shift;

    $self -> clear_error();

    my $acth = $self -> {"dbh"} -> prepare("SELECT activated FROM ".$self -> {"settings"} -> {"database"} -> {"users"}."
                                            WHERE user_id = ?");
    $acth -> execute($userid)
        or return $self -> self_error("Unable to perform user activation check: ". $self -> {"dbh"} -> errstr);

    my $act = $acth -> fetchrow_arrayref();
    return $act ? $act -> [0] : 0;
}


## @method $ activate_user($userid)
# Activate the user account with the specified id. This clears the user's
# activation code, and sets the activation timestamp.
#
# @param userid The ID of the user account to activate.
# @return true on success, undef on error.
sub activate_user {
    my $self   = shift;
    my $userid = shift;

    $self -> clear_error();

    my $activate = $self -> {"dbh"} -> prepare("UPDATE ".$self -> {"settings"} -> {"database"} -> {"users"}."
                                                SET activated = UNIX_TIMESTAMP(), act_code = NULL, fail_count = 0
                                                WHERE user_id = ?");
    my $rows = $activate -> execute($userid);
    return $self -> self_error("Unable to perform user update: ". $self -> {"dbh"} -> errstr) if(!$rows);
    return $self -> self_error("User update failed, no rows modified - bad userid?") if($rows eq "0E0");

    return 1;
}


## @method @ reset_password_actcode($userid)
# Forcibly reset the user's password and activation code to new random values.
#
# @param userid The ID of the user to reset the password and act code for
# @return The new password and activation code set for the user
sub reset_password_actcode {
    my $self   = shift;
    my $userid = shift;

    my $actcode  = join("", map { ("a".."z", "A".."Z", 0..9)[rand 62] } 1..64);
    my $password = join("", map { ("a".."z", "A".."Z", 0..9)[rand 62] } 1..10);

    # Hash the password using the method AuthMethod::Database uses internally
    my $cryptpass = $self -> hash_password($password);

    my $reseth = $self -> {"dbh"} -> prepare("UPDATE ".$self -> {"settings"} -> {"database"} -> {"users"}."
                                              SET password = ?, act_code = ?, password_set = UNIX_TIMESTAMP(), force_change = 1, activated = NULL
                                              WHERE user_id = ?");
    my $rows = $reseth -> execute($cryptpass, $actcode, $userid);
    return $self -> self_error("Unable to perform user update: ". $self -> {"dbh"} -> errstr) if(!$rows);
    return $self -> self_error("User update failed, no rows changed.") if($rows eq "0E0");

    return ($password, $actcode);
}


## @method $ reset_password($userid)
# Forcibly reset the user's password to a new random value.
#
# @param userid The ID of the user to reset the password for
# @return The (unencrypted) new password set for the user
sub reset_password {
    my $self   = shift;
    my $userid = shift;

    my $password = join("", map { ("a".."z", "A".."Z", 0..9)[rand 62] } 1..10);

    # Hash the password using the method AuthMethod::Database uses internally
    my $cryptpass = $self -> hash_password($password);

    my $reseth = $self -> {"dbh"} -> prepare("UPDATE ".$self -> {"settings"} -> {"database"} -> {"users"}."
                                              SET password = ?, password_set = UNIX_TIMESTAMP(), force_change = 1
                                              WHERE user_id = ?");
    my $rows = $reseth -> execute($cryptpass, $userid);
    return $self -> self_error("Unable to perform user update: ". $self -> {"dbh"} -> errstr) if(!$rows);
    return $self -> self_error("User update failed, no rows changed.") if($rows eq "0E0");

    return $password;
}


## @method $ set_password($userid, $password)
# Set the user's password to the specified value.
#
# @param userid   The ID of the user to set the password for
# @param password The password to set for the user.
# @return True on success, undef on error.
sub set_password {
    my $self     = shift;
    my $userid   = shift;
    my $password = shift;

    # Hash the password using the method AuthMethod::Database uses internally
    my $cryptpass = $self -> hash_password($password);

    my $reseth = $self -> {"dbh"} -> prepare("UPDATE ".$self -> {"settings"} -> {"database"} -> {"users"}."
                                              SET password = ?, password_set = UNIX_TIMESTAMP()
                                              WHERE user_id = ?");
    my $rows = $reseth -> execute($cryptpass, $userid);
    return $self -> self_error("Unable to perform user update: ". $self -> {"dbh"} -> errstr) if(!$rows);
    return $self -> self_error("User update failed, no rows changed.") if($rows eq "0E0");

    return 1;
}


## @method $ generate_actcode($userid)
# Generate a new activation code for the specified user.
#
# @param userid The ID of the user to reset the act code for
# @return The new activation code for the user
sub generate_actcode {
    my $self   = shift;
    my $userid = shift;

    my $actcode  = join("", map { ("a".."z", "A".."Z", 0..9)[rand 62] } 1..64);

    my $reseth = $self -> {"dbh"} -> prepare("UPDATE ".$self -> {"settings"} -> {"database"} -> {"users"}."
                                              SET act_code = ?
                                              WHERE user_id = ?");
    my $rows = $reseth -> execute($actcode, $userid);
    return $self -> self_error("Unable to perform user update: ". $self -> {"dbh"} -> errstr) if(!$rows);
    return $self -> self_error("User update failed, no rows changed.") if($rows eq "0E0");

    return $actcode;
}


## @method @ mark_loginfail($userid)
# Increment the login failure count for the specified user. The following configuration
# parameter (which should be set for each applicable authmethod in the auth_method_params
# table) is used to control the login failure marking process:
#
# - `policy_max_loginfail`, the number of login failures a user may have before their
#   account is deactivated.
#
# @warning Login failure limiting should not be performed unless account activation
#          and password changes are supported. Otherwise the system has no means of
#          preventing attempts to log in past the limit.
#
# @param userid The ID of the user to increment the login failure counter for.
# @return An array containing two values: The first is the number of login failures
#         recorded for the user, the second is the number of allowed failures. If
#         the second value is zero, no failure limiting is being performed. If an error
#         occurs or the user does not exist, both values are undef.
sub mark_loginfail {
    my $self   = shift;
    my $userid = shift;

    my $userh = $self -> {"dbh"} -> prepare("SELECT fail_count
                                             FROM ".$self -> {"settings"} -> {"database"} -> {"users"}."
                                             WHERE user_id = ?");
    $userh -> execute($userid)
        or return $self -> self_error("Unable to perform user lookup: ". $self -> {"dbh"} -> errstr);

    my $failcount = $userh -> fetchrow_arrayref();

    # Halt if the user does not exist
    return (undef, undef) unless($failcount);

    # Do nothing if limiting is not enabled
    return (0, 0) unless($self -> {"policy_max_loginfail"});

    ++$failcount;

    # update the login fail counter
    $userh = $self -> {"dbh"} -> prepare("UPDATE ".$self -> {"settings"} -> {"database"} -> {"users"}."
                                          SET fail_count = ?
                                          WHERE user_id = ?");
    my $rows = $userh -> execute($failcount, $userid);
    return $self -> self_error("Unable to perform user failcount update: ". $self -> {"dbh"} -> errstr) if(!$rows);
    return $self -> self_error("Unable to perform user failcount update: no rows changed") if($rows eq "0E0");

    return ($failcount, $self -> {"policy_max_loginfail"});
}


## @method $ force_passchange($userid)
# Determine whether the user needs to reset their password (either because they are
# using a temporary system-allocated password, or the password policy requires it).
#
# If a password expiration policy is in use, `policy_max_passwordage` should be set
# in the auth_method_params for the applicable authmethods. The parameter should contain
# the maximum age of any given password in days. If not set, expiration is not
# enforced.
#
# @param userid The ID of the user to check for password change requirement.
# @return 'temporary' if the user must change their password because it is a
#         temporary one, 'expired' if the password has expired, the empty string if
#         the password does not need to be changed, undef on error.
sub force_passchange {
    my $self   = shift;
    my $userid = shift;

    my $passh = $self -> {"dbh"} -> prepare("SELECT force_change, password_set
                                             FROM ".$self -> {"settings"} -> {"database"} -> {"users"}."
                                             WHERE user_id = ?");
    $passh -> execute($userid)
        or return $self -> self_error("Unable to perform passchange check: ". $self -> {"dbh"} -> errstr);

    my $pass_data = $passh -> fetchrow_hashref()
        or return ''; # Unknown user? Can't change the password even if we'd like to.

    # Check for password expiration based on policy settings
    my $age = time() - ($pass_data -> {"password_set"} || 0); # Handle NULL password_set's sanely
    return 'expired' if($self -> {"policy_max_passwordage"} && ($age > ($self -> {"policy_max_passwordage"} * 86400)));

    # Check for temporary passwords
    return 'temporary' if($pass_data -> {"force_change"});

    # Otherwise, no need to change the password
    return '';
}


# ============================================================================
#  Ghastly internals

## @fn private $ generate_settings($cost)
# Generate a settings string to provide to bcrypt(). This will generate a
# string in the form '$2$', followed by the cost - which will be padded with a
# leading zero for you if it is less than 10, and does not have one already -
# followed by '$' and then a 22 character Base64 encoded string containing the
# password salt.
#
# @todo This uses /dev/urandom directly, which is not only unportable, it
#       is cryptographically weak. /dev/random fixes the latter - at the cost
#       of potentially blocking the user, and has therefore been avoided.
#       Possibly switching to Crypt::Random, and doing account creation
#       asynchronously (ie: users do not get immediately created accounts)
#       would allow proper strength salting in a potentially platform-neutral
#       fashion here.
#
# @param cost The cost of the hash. The number of hash iterations is 2^cost.
#             This should be as high as possible (at least 14, preferably over 16)
#             while not drastically slowing user login.
# @return A settings string suitable for use with bcrypt().
sub generate_settings {
    my $cost = shift;

    # Make sure the cost has a leading zero if needed.
    $cost = "0$cost"
        unless($cost > 9 || $cost =~ /^0\d$/);

    # Bytes, bytes, we need random(ish) byes!
    open(RND, "/dev/urandom")
        or die "Unable to open random source: $!\n";
    binmode(RND);

    my $buffer;
    my $read = read(RND, $buffer, 16);
    die "Unable to read 16 bytes from random source: $!\n" if($read != 16);
    close(RND);

    # Can't use MIME::Base64 directly here as bcrypt() expects a somewhat...
    # idiosycratic variation of base64 encoding. Use its own encoder instead.
    return '$2$'.$cost.'$'.en_base64($buffer);
}

1;
